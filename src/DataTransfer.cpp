// This class is responsible for using the ho solver to calculate parameters for the
// lo order solver and setting those in the LO system via the mesh that is passed in
// (currently lo order data is stored on each mesh).  Ho Solver can compute the half
// range fluxes.  


//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : DataTransfer.cpp
//  @ Date : 2/7/2014
//  @ Author : 
//
//


#include "../include/DataTransfer.h"
#include <iostream>

DataTransfer::DataTransfer(HoSolver* ho_solver, Mesh* mesh):
_ho_solver(ho_solver),
_mesh(mesh)
{}

void DataTransfer::updateLoSystem()
{
	//Loop over elements in the mesh
	Element* current_element;
	LoData1D lo_data;
	
	for (int el = 0; el < _mesh->getNumElems(); ++el)
	{
		current_element = _mesh->getElement(el);
		calculateLoData(lo_data, el);
		current_element->setLoData(lo_data);
	}
}

void DataTransfer::calculateLoData(LoData1D & lo_data, int element_id)
{
	//Currently it is teh responsibility of the ho solver to calculate the
	//lo data.  Eventually this could be changed by virtual overriding this
	//function for differnet dimensions.  This is currently a fairly pointless
	//class.

	_ho_solver->getLoData1D(lo_data, element_id);
} 

void DataTransfer::printLoDataEl(int element_id, std::ostream & out) const
{
	LoData1D lo_data = _mesh->getElement(element_id)->getLoData();
	out << "Element ID = " << element_id;
	out << "-- Spatial Closure Factor = " << lo_data.getSpatialClosureFactor();
	out << "\n-- " << "Surface Cosines, left, minus to right, plus -- \n ";
	
	AveragedCosines cosines = lo_data.getSurfAveragedCos();
	out.setf(ios::scientific);
	out.precision(15);
	out << "  " << cosines._mu_left_minus << std::endl;
	out << "  " << cosines._mu_left_plus << std::endl;
	out << "  " << cosines._mu_right_minus << std::endl;
	out << "  " << cosines._mu_right_plus << std::endl;
	
	out << "-- " << "Volume Cosines, left, minus to right, plus -- \n";

	cosines = lo_data.getVolAveragedCos();
	out.setf(ios::scientific);
	out.precision(15);
	out << "  " << cosines._mu_left_minus << std::endl;
	out << "  " << cosines._mu_left_plus << std::endl;
	out << "  " << cosines._mu_right_minus << std::endl;
	out << "  " << cosines._mu_right_plus << std::endl;
	out << "\n";
}

void DataTransfer::printAllLoData(std::ostream & out) const
{
	if (HoController::WRITE_ALL_LO_DATA)
	{
		for (int i = 0; i < _mesh->getNumElems(); ++i)
		{
			printLoDataEl(i, out);
		}
	}
}
