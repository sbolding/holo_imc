// This class sets the DOF for the LO system (in 1D) before solving.  Each time it is
// called it ensures that the matrix is of the correct size.  There is currently no way 
// to 
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : LoSolver1D.cpp
//  @ Date : 11/1/2013
//  @ Author : 
//
//

#include "../include/GlobalConstants.h"
#include "../include/Controller.h"
#include "../include/LoSolver1D.h"
#include "../include/numMatrixFull.h" //used for building the local 4x4 system

LoSolver1D::LoSolver1D(Mesh* mesh) : LoSolver(1, mesh)
{
	//Set the degrees of freedom for 1D element
	_n_dof = _mesh->getNumElems() * 4;
}

void LoSolver1D::assembleSystem()
{
	using namespace std;

	//Local variables
	vector<Element *>* elements;	        //Pointer to elements vector
	numVector* local_load_vector;			//local rhs terms
	numMatrixFull* local_moment_matrix;		//local lhs terms
	vector<int> global_eqn_indices;			//Global equation numbers
	int n_element_dof;						//number of element degrees of freedom
	int row, col;							//Global row and col (eqn numbers)
	vector<DirichletBC1D *> dirichlet_bcs;	//Local dirichlet boundary conditions
	vector<double> upwind_terms;			//Local upwind terms from current element to "next"

	//Get the new degrees of freedom, in case mesh has changed since initialization
	setNumDof();

	//Get BC from the matrix
	dirichlet_bcs = _mesh->getDirichletBCs();

	//Initialize matrix and load vector, need to manually clear sol_vec
	deleteMatrixVector();
	delete _sol_vec; _sol_vec = NULL;
	_system_matrix = new numMatrixBanded(_n_dof, 7);
	_system_vec = new numVector(_n_dof);
	_sol_vec = new numVector(_n_dof);

	//-------------------------------------------------------------------------------
	//Build matrix and load vector
	//-------------------------------------------------------------------------------
	elements = _mesh->getElements();
	std::vector<Element*>::iterator it_el;  //element iterator
	it_el = elements->begin();				//initialize iterator

	//Get the DOF for each element and initialize local matrices
	n_element_dof = (*it_el)->getNumDof();
	local_moment_matrix = new numMatrixFull(n_element_dof, n_element_dof);
	local_load_vector = new numVector(n_element_dof);

	for (; it_el != elements->end(); it_el++)
	{
		//Get local matrix and vector terms to add to LHS and RHS for this element
		//This function also returns the corresponding equation numbers
		(*it_el)->getElementMomentMatrix(local_moment_matrix, 
			local_load_vector, global_eqn_indices, _mesh->_ext_source_functor);

		//Add local matrix to global matrix //TODO this is probalby not going to work in multidimension
		for (int i_row = 0; i_row < n_element_dof; i_row++)
		{
			row = global_eqn_indices[i_row];
			for (int i_col = 0; i_col < n_element_dof; i_col++)
			{
				col = global_eqn_indices[i_col];
				_system_matrix->addCoeff(row, col, local_moment_matrix->getCoeff(i_row, i_col));
			}
			_system_vec->addCoeff(row, local_load_vector->getCoeff(i_row));
		}

		//Add in the positive and negative direction upwinding terms
		if ( (it_el != (--elements->end())) && (elements->size() > 1 ) ) //then there is positive direction upwinding
		{
			(*it_el)->getPosUpwinding(upwind_terms, row, global_eqn_indices);			
			if (global_eqn_indices.size() != 2) //Should be of length 2
				cerr << "Pos Upwinding is not working properly, local matrices returned too many eqn numbers" << endl;
			for (int i_col = 0; i_col < global_eqn_indices.size(); i_col++)
				_system_matrix->addCoeff(row, global_eqn_indices[i_col], upwind_terms[i_col]);
		}
		if ( (it_el != elements->begin()) && (elements->size() > 1 ) ) //then there is negative direction upwinding
		{
			(*it_el)->getNegUpwinding(upwind_terms, row, global_eqn_indices);
			if (global_eqn_indices.size() != 2) //Should be of length 2
				cerr << "Neg Upwinding is not working properly, local matrices returned too many eqn numbers" << endl;
			for (int i_col = 0; i_col < global_eqn_indices.size(); i_col++)
				_system_matrix->addCoeff(row, global_eqn_indices[i_col], upwind_terms[i_col]);
		}

		//Reset local vectors
		local_load_vector->zero();
		local_moment_matrix->zero();
	} //end of for loop over elements

	//--------------------------------------------------------------------------------
	//Add in Boundary Conditions
	//--------------------------------------------------------------------------------
	std::vector<DirichletBC1D *>::iterator it_bc; //Boundary condition iterator
	it_bc = dirichlet_bcs.begin();
	for (; it_bc != dirichlet_bcs.end(); it_bc++)
	{
		//Get local vector to add for BC
		(*it_bc)->getElement()->addDirichletBC(local_load_vector, global_eqn_indices, 
			(*it_bc)->getCurrent(), (*it_bc)->getNode());

		//Add boundary condition terms from the load vector, global
		//eqn indices should be of length 2
		for (int i_row = 0; i_row < n_element_dof; i_row++)
		{
			row = global_eqn_indices[i_row];
			_system_vec->addCoeff(row, local_load_vector->getCoeff(i_row));
		}
	}

	//Clean up dynamic memory
	delete local_load_vector;
	delete local_moment_matrix;
}


LoSolver1D::LoSolver1D() : LoSolver() 
{
} //Default Constructor

void LoSolver1D::printSolution(std::ostream& out)
{
	if (LoController::WRITE_SOLUTION)
	{
		_sol_vec->print(out);
	}
}

void LoSolver1D::solveSystem()
{
	//Output
	std::cout << "Solving the low order system...\n";

	//Assemble 1D system
	assembleSystem();

	//Output to screen if desired
	if (LoController::WRITE_MATRIX)
	{
		std::cout << "\nSystem before solving:\n";
		printSystem(std::cout);
	}

	//Solve linear system;
	solveLinearSystem();

	//Output to screen if desired
	if (LoController::WRITE_MATRIX)
	{
		std::cout << "\nSystem after solving:\n";
		printSystem(std::cout);
	}

	//Free up memory from matrix and load vector, NOT system vector
	deleteMatrixVector();

	//Map solution vector onto element DOF
	updateSystem();
}

void LoSolver1D::setNumDof()
{
	//Set the degrees of freedom for 1D element
	// The four unknowns for each element are the L and R moments in +/- directions
	_n_dof = _mesh->getNumElems() * 4;
}