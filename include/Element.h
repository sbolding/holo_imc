// General element.  All types of elements should inherit from this class
// TODO there is no reason that the element should keep its dimension
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Element.h
//  @ Date : 11/1/2013
//  @ Author : 
//
//


#if !defined(_ELEMENT_H)
#define _ELEMENT_H

#include <vector>
#include "Node.h"
#include "LoData1D.h"
#include "MaterialConstant.h"
#include "Dof.h"
#include "numMatrix.h"
#include "FixedSourceFunctor.h"

class Element
{
protected:

	//Variables
    int _n_nodes;			  //number of nodes on an element
    int _dimension;			  //dimension of problem
    int _id;                   //Each element has an ID number to correspond to the mesh element ID numbers
    std::vector<Node*> _nodes; //vector of the pointers to node objects
    int _n_elem_dof;		    //Number of degrees of freedom for this element, must be set in the derived classes
	Element();					//Default Constructor, never use
	LoData1D* _lo_data;			//All "data" needed for constructing low order system over each element.  Each element should have their own LoData
	MaterialConstant* _mat;     
	std::vector<Dof > _elem_dofs; //The dof values for element, contains eqn numbers, and values once solved.
	std::vector<double> _ext_source_nodal_values; //The values of the external source on the nodes

	//Methods
	virtual void getScalarFluxValues(double alpha, std::vector<double> &scalar_flux_values,
		std::vector<double> &locations) const = 0;  //Return the flux values on the faces (nodes in 1D)


public:

  Element(int dimension, int id, MaterialConstant* mat, std::vector<Node* >  nodes);	//pass in pointers to nodes
	virtual void print(std::ostream &out) const = 0; //pure virtual print function
	//TODO set data and material outside of class because these will not remain constant over solution
	void setLoData(LoData1D &LoData);
	void setMaterial(MaterialConstant &mat);
	void setExtSourceNodalValues(std::vector<double> ext_source_nodal_values);

	//Get Data 
	LoData1D getLoData(void) const;
	MaterialConstant getMaterial(void) const;
	int getMaterialID(void) const;
	virtual void setElementDof(std::vector<double> element_dof_values) = 0; //Pure Virtual Function must be implemented within class
	int getNumDof(void) const;				//Return the number of DOF for each element
	int getID(void) const;
	int getNumNodes(void) const;
	std::vector<double> getExtSourceNodalValues(void) const;
	virtual std::vector<double> getScalarFluxNodalValues(void) const = 0; //returns a vector of the scalar flux nodal values needed for HO solver
	virtual std::vector<double> getElementDimensions(void) const =0; //returns a vector of dimensional values in order: width, height, depth for 3D
	virtual std::vector<double> getNodalCoordinates(void) const = 0; //returns a vector of the nodal coordinates of the element
	virtual std::vector<double> getSpatialCoordinates(void) const = 0; //returns a vector of the coordinates corresponding to the center of spatial element

	//For constructing the system
	virtual std::vector<int> getEqnNumbers(void) const = 0;		//Get the equation numbers corresponding to each DOF
	virtual void getElementMomentMatrix(numMatrix* M, numVector* b,
		std::vector<int> &eqns, FixedSourceFunctor *q = NULL) const = 0;	//Returns the moment equations for an element, including upwinded terms.  
	virtual void addDirichletBC(numVector* b, std::vector<int> &eqns,
		double value, Node* node) const = 0;  //Will return values to modify global vector correctly, TODO bad coding
	virtual void getPosUpwinding(std::vector<double> &values, int &eqn,
		std::vector<int> &cols) const = 0;	//Will return upwinding terms in + dir, which row, and which cols
	virtual void getNegUpwinding(std::vector<double> &values, int &eqn, 
		std::vector<int> &cols) const = 0;	//Will return upwinding terms in - dir, which row, and which cols
	virtual void getScalarFluxLinDisc(std::vector<double> &scalar_flux_values,
		std::vector<double> &locations) const = 0; //Returns scalar flux on faces using Linear Discontinuous approximation, locations is face coordinates
	virtual void getScalarFluxHOClosure(std::vector<double> &scalar_flux_values,
		std::vector<double> &locations) const = 0; //This is for scalar flux based on alpha closure, shouldnt be used except verification
	virtual void printLDScalarFluxValues(std::ostream &out) const = 0; //Print out the LD scalar flux and nodes
};

#endif  //_ELEMENT_H
