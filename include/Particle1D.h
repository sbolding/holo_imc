//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  High Order Solver
//  @ File Name : Particle1D.h
//  @ Date : 1/27/2014
//  @ Author : Simon R Bolding
//
//


#if !defined(_PARTICLE1D_H)
#define _PARTICLE1D_H

#include <string>
#include "HoMesh.h"
#include "RNG.h"
#include "GlobalConstants.h"
#include "AliasSampler.h"

//forward declarations for friend classes
class Source; 
class LinDiscSource;
class ResidualSource;
class StandardResidualSource;
class StratifiedResidualSource;

class Particle1D
{
protected:

	HoMesh* _mesh;
	unsigned int _method; //type of MC
	RNG* _rng;

	//Sampling properties, use friend classes that handle the source sampling
	friend class Source;
	friend class LinDiscSource;
	friend class ResidualSource;
	friend class StandardResidualSource;
	friend class StratifiedResidualSource;
	Source* _source; //This may be NULL initialy, it is the source's constructors responsibility to set this pointer correctly

	//general particle properties
	double _position_mfp;
	double _mu;
	double _weight;

	//debugging properties, generally won't be used
	int _n_scat;
	int _n_abs;
	int _n_leak;
	int _n_terminations; //how many times was terminateHistory() called?

	//material properties for the current element
	double _sigma_tot;
	double _mfp_tot;
	double _scat_ratio;
	double _sigma_abs;
	double _sigma_scat;
	double _element_width_mfp; //in MFP to ray trace easily
	double _element_angular_width; //for tallying

	//data for tracking across elements
	int _current_element_ID;	//which element are you in
	int _current_mat_ID;  //Material of current element
	ECMCElement1D* _current_element; //Pointer to the current ECMC element
	Element* _spatial_element; //Pointer to the spatial element you are currently in
	size_t _n_elements;		//for sampling which element a particle is born in
	bool _is_dead;		 //for terminating particle history

	//protected methods
	//---------------------------------------------
	//Streaming and collision methods
	double samplePathLength();      //Sample a path length in cm
	double samplePathLengthMFP();   //Sample a path length in units of number of MFP, useful for streaming through many cells
	double sampleAngleIsotropic();	//returns a cosine sampled from uniform distribution
	void sampleCollision();  //Determine if a scatter or an absorption, and then do teh appropriate behavior after that, depending on solver method
	void streamToNextEvent(double path_length_mfp); //stream from current position to next interaction or leakage, this is it's own class for the sake of virtual overriding for derived particle classes
	void updateElementProperties();
	void leaveElement();	//Called when leaving an element and moving into next geometrical region
	void terminateHistory(); //kill particle, do other appropriate things

	//tallies
	void scoreFaceTally(); //this doesnt make sense in ECMC context, just for verifying particles are being tracked properly
	virtual void scoreElementTally(double path_start_mfp, double path_end_mfp); //passed where the track begin and ended, in terms of x-coordinate

	//Sampling the source methods
	void sampleSourceParticle();	//this function initializes the particles weight etc., then calls the 
	inline void initializeHistory(); //This is in the particle class to ensure it is called everytime
	
public:

	//constructors
	Particle1D(HoMesh* mesh, Source* src, RNG* rng, string method_str); //Standard constructor, pass a pointer for rng to make sure 
	//you dont resample random numbers, method_str is which solution method from HoSolver (ECMC etc.).  Source is passed by pointer
	//because the source has most likely not been constructed yet.  It is the source constructor's responsibility to set Particle1D
	//'s src pointer to the newly created source!!!!!
	
	//public functions
	double getRandNum();
	virtual void runHistory();  //sample source, then stream particle til history termination
	void printParticleBalance(int n_histories, bool reset_balances = true); //after printing particle balance (if turned on), then reset the balances if desired
	void resetParticleBalance(); //zero out the particle balance counters 

};

#endif  //_PARTICLE1D_H
